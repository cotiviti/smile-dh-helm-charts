# Configuring TLS Encryption
This Helm Chart supports multiple mechanisms for enabling encryption of data in transit. This feature is currently under active development in order to simplify the configuration of end-to-end encryption.

End-to-end encryption is currently an opt-in feature that needs to be explicitly enabled.

## Default Configuration
Currently, even though the Helm Chart defaults enable TLS encryption for the end-user, it is not enabled by default directly on the Smile CDR HTTP endpoints used internally within the cluster.

This results in the following encryption configurations between the client and Smile CDR, depending on your choice of ingress.

### Using ingress-nginx for ingress (Default)
If you have left your ingress definition to use the default of `nginx-ingress` ([See Here](./ingress.md#nginx-ingress)), encryption will be configured as follows:

* TLS encryption between client and the AWS Network Load Balancer using ACM certificate provided when configuring the ingress-nginx controller.
* TLS encryption from the NLB to the Nginx ingress controller using self-signed certificate automatically generated by the ingress controller.
* Unencrypted from the Nginx ingress controller to the Smile CDR pods.

### Using AWS Application Load Balancer for ingress
If you have set your ingress definition to use `aws-lbc-alb` ([See Here](./ingress.md#aws-load-balancer-controller)), encryption will be configured as follows:

* TLS encryption between client and the AWS Application Load Balancer using ACM certificate specified in your `Ingress` resource.
* Unencrypted from the ALB to the Smile CDR pods.

### Using Azure Application Gateway Ingress Controller for ingress
If you have set your ingress definition to use `azure-agic` ([See Here](./ingress.md#azure-application-gateway-ingress-controller)), encryption is not currently supported.

## Enabling TLS

This helm chart leverages the [cert-manager](https://cert-manager.io/) X.509 certificate controller to provision and manage any required certificates. As such, this controller is a requirement to enable TLS beyond the default configurations mentioned above.

TLS certificate generation is enabled by configuring `Issuer` and `Certificate` resources in the cluster. For convenience, the Helm Chart will create default issuers and certificates and auto-configure Smile CDR to use them. It is also possible to disable these defaults to define your own.

### Enable Default 'cluster-signed' certificates

To enable default ***end-to-end*** encryption, add the following to your `values.yaml` file.

```
tls:
  certificateIssuers:
    default:
      enabled: true
  certificates:
    default:
      enabled: true
  defaultEndpointConfig:
    enabled: true
```

??? Explanation
    #### `certificateIssuers`
    The `certificateIssuers` configuration is used to define cert-manager `Issuer` resources.
    The provided ***default*** issuer configuration will create the following resources in the same namespace as the Smile CDR deployment:

    * A *self-signed* Issuer that is used for signing the *cluster-local* Issuer that will act as the CA for this namespace.
    * A *cluster-local* Issuer that is used for signing certificates to be used by Smile CDR
        * This `Issuer` resource is designated as the default issuer for any `Certificate` resources that do not explicitly specify an `Issuer`.

    This default issuer can be used, or it can be disabled if you wish to define your own issuers.

    #### `certificates`
    The `certificates` configuration is used to define cert-manager `Certificate` resources.
    The provided ***default*** certificate configuration will create the following resources in the same namespace as the Smile CDR deployment:

    * A certificate that is used as the default for any resources auto-configured to use TLS encryption
    * A certificate that is used for enabling TLS encryption on Smile CDR HTTP Endpoint modules
        * This certificate is signed by whichever `Issuer` resource is designated as the default.
        * This `Certificate` is designated as the default for any resources auto-configured to use TLS encryption

    This default certificate can be used, or it can be disabled if you wish to define your own certificates.

    #### `defaultEndpointConfig`
    The `defaultEndpointConfig` configuration is used to set the default auto-configuration of the Smile CDR HTTP Endpoint modules.
    By enabling this option, all HTTP endpoint modules will use whichever `Certificate` is designated as the default.

    Individual modules may also be configured to use their own certificate configurations, this will override the `defaultEndpointConfig`

Simply adding the above code will result in the following encryption configurations between the client and Smile CDR, depending on your choice of ingress.

#### Using ingress-nginx for ingress (Default)
If you have left your ingress definition to use the default of `nginx-ingress` ([See Here](./ingress.md#nginx-ingress)), default end-2-end encryption will be configured as follows:

* TLS encryption between client and the AWS Network Load Balancer using ACM certificate provided when configuring the ingress-nginx controller.
* TLS encryption from the NLB to the Nginx ingress controller using self-signed certificate automatically generated by the ingress controller.
    * See below note on Nginx TLS configuration
* TLSv1.3 encryption from the Nginx ingress controller to the Smile CDR pods using `cluster-signed` certificate.
    * Uses `nginx.ingress.kubernetes.io/configuration-snippet` annotation.
    * If this annotation is disabled, then the Nginx ingress controller should be configured to use TLSv1.3
* Kubernetes Readiness Probes updated to use HTTPS
* Smile CDR module endpoints configured as follows:
    * TLS Protocol restricted to `TLSv1.3`
    * TLS restricted to the following recommended ciphers, which are known to work with the ELB Security Policy and the Kubernetes Kubelet:
        * `TLS_AES_128_GCM_SHA256`
        * `TLS_AES_256_GCM_SHA384`
        * `TLS_CHACHA20_POLY1305_SHA256`

>**Note:** If you wish to wish to avoid the use of the default self-signed certificate that is automatically provisioned by the Nginx Ingress controller,
you can configure it to use one of the cert-manager `Issuer` resources to automatically provision a more appropriate certificate. Please see the [TLS Encryption section](./ingress.md#tls-encryption) of the [Ingress documentation](./ingress.md).

#### Using AWS Application Load Balancer for ingress
If you have set your ingress definition to use `aws-lbc-alb` ([See Here](./ingress.md#aws-load-balancer-controller)), default end-to-end encryption will be configured as follows:

* TLS encryption between client and the AWS Application Load Balancer using ACM certificate specified in your `Ingress` resource.
* ELB Security policy is set to a secure default that supports TLSv1.3 (`ELBSecurityPolicy-TLS13-1-2-FIPS-2023-04`)
* TLS encryption from the ALB to the Smile CDR pods using `cluster-signed` certificate.
* AWS ALB Health Probes configured to use HTTPS
* Smile CDR module endpoints configured as follows:
   * TLS Protocol restricted to `TLSv1.3`
   * TLS restricted to the following recommended ciphers, which are known to work with the ELB Security Policy and the Kubernetes Kubelet:
      * `TLS_AES_128_GCM_SHA256`
      * `TLS_AES_256_GCM_SHA384`
      * `TLS_CHACHA20_POLY1305_SHA256`
   * `tls_debug_disable_sni_check` set to true.

>**Note:** In order for the HTTPS healthchecks to work when using the AWS ALB, the disable sni check option must be set. Currently, this will result in a warning in the Smile CDR console suggesting to disable the option. This is unavoidble at this time.

These defaults may be updated via your Helm Values file. See the [Advanced Configuration](#advanced-configuration) below.

#### Using Azure Application Gateway Ingress Controller for ingress
If you have set your ingress definition to use `azure-agic` ([See Here](./ingress.md#azure-application-gateway-ingress-controller)), encryption is not currently supported.

## Advanced Configuration
If the above defaults are not suitable, much of the functionality can be customized.

### Currently configurable options
The following can be updated.
>**Note:** If you need assistance while the advanced configuration documentation is still being created, please contact us.

* Create custom cluster-local issuers
* Create custom certificates
* Manually configure individual HTTP Endpoint modules to use different certificates
* Configure using mixed-schema endpoints (i.e. some endpoints use HTTPS and some use HTTP). Note that multiple Ingress resources are required for this scenario

### Create **Let's Encrypt** `Issuer` resources
This Helm Chart can be configured to easily and automatically provision a lets-encrypt, or other ACME compliant issuer.

In order to enable this feature, your `certificateIssuer` configuration must include at the minimum the following:

* `signingMethod: public-signed`
* `acmeSpec.email: your@email.com`

>**Note:** Although cert issuance functions with an invalid e-mail address, it is used by the provider to track your certificates and provide notifications about the status of your certificates. It's advisable to use a correct e-mail address.

Here is how that would look in your values file.
```
tls:
  certificateIssuers:
    acmeStaging:
      enabled: true
      signingMethod: public-signed
      acmeSpec:
        email: your@email.com
```

By default, the above will use the Let's Encrypt ***Staging*** servers and produce an `Issuer` resource with the following spec:

```
spec:
  acme:
    email: your@email.com
    privateKeySecretName:
      name: release-name-smilecdr-acmestaging-key
    server: https://acme-staging-v02.api.letsencrypt.org/directory
    solvers:
    - http01:
        ingress:
          ingressClassName: nginx
```

For convenience, you may set `acmeSpec.server` to some pre-defined friendly names. You can also set it directly to an ACME server of your choosing.

The following convenience server names are provided:

* `lets-encrypt-staging` - `https://acme-staging-v02.api.letsencrypt.org/directory` (Default)
* `lets-encrypt-prod` - `https://acme-v02.api.letsencrypt.org/directory`

#### Using ACME Issuer with AWS ALB
At this time, the automatically generated ACME Issuer uses [HTTP01 Challenges](https://cert-manager.io/docs/configuration/acme/http01/) and will only work if your environment is configured to use the `ingress-nginx` Ingress Controller. If you wish to use ACME certificates with AWS ALB, there are some challenges as the cert-manager `Challenge` resource creates an Ingress resource with `IngressClass: alb`.

As this challenge mechanism relies on creating an ingress route that is resolvable from the environment's URL, it needs to use the same AWS ALB instance. In order to achieve this, the following steps need to be taken:

* Re-deploy your ALB ingress using the `alb.ingress.kubernetes.io/group.name: tlstest` annotation.
   * Note that if you are adding this value, your existing ALB may be destroyed replaced by thwe AWS Load Balancer Controller. Any DNS entries pointing to the old one may need to be updated.
* Define and manually create an `Issuer` resource that uses an `ingressTemplate` that includes the same group name annotation.
* Configure an Issuer (in your values file) that references the above Issuer resource that you manually created.
   * See the [pre-existing Issuers](#use-pre-existing-cert-manager-issuer-or-clusterissuer-resources) section below for more info on using existing Issuers or ClusterIssuers.

Now, when the `Certificate` resource is created, an `HTTP01` challenge route will be created on the existing AWS ALB and the certificate will be provisioned.

The following snippets demonstrate how to achieve this:

In your `values.yaml` file
```
ingresses:
  default:
    type: aws-lbc-alb
    annotations:
      alb.ingress.kubernetes.io/group.name: tlstest

tls:
  certificateIssuers:
    default:
      enabled: true
      signingMethod: public-signed
      existingIssuer: my-existing-le-issuer-with-alb
  certificates:
    default:
      enabled: true
  defaultEndpointConfig:
    enabled: true
```

Manually created `Issuer` resource:
```
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: my-existing-le-issuer-with-alb
spec:
  acme:
    email: test2@exampledomain.com
    privateKeySecretName:
      name: smilecdr-my-existing-le-issuer-key
    server: https://acme-staging-v02.api.letsencrypt.org/directory

    solvers:
    - http01:
        ingress:
          ingressClassName: alb
          ingressTemplate:
            metadata:
              annotations:
                alb.ingress.kubernetes.io/group.name: tlstest
                alb.ingress.kubernetes.io/listen-ports: "[{\"HTTP\":80},{\"HTTPS\":443}]"
                alb.ingress.kubernetes.io/scheme: internet-facing
                alb.ingress.kubernetes.io/ssl-redirect: "443"
```

Note that it is important for all of the above annotations to be present so that the `HTTP01` challenge gets successfully set up. The ingress resource that is created is transient and will only be present for the duration of the certificate ordering process.

For more information on any other settings that may be used in the `acmeSpec`, please refer to the official cert-manager Issuer documentation [here](https://cert-manager.io/docs/configuration/issuers/).

### Use pre-existing cert-manager `Issuer` or `ClusterIssuer` resources
If you have already provisioned one or more cert-manager issuers through other mechanisms, you can use them instead of having the Helm Chart create them for you.

To do this, you will still need to create an issuer configuration under `certificateIssuers` so that the Helm Chart knows what kind of issuer it is working with.

```
tls:
  certificateIssuers:
    myExistingIssuer:
      enabled: true
      existingIssuer: theIssuerResourceName
      # existingClusterIssuer: theClusterIssuerResourceName
      # signingMethod: public-signed

```

By default, this issuer will be treated as a 'cluster-signed' issuer. This means that any certificate requests may include Kubernetes service entries in the SAN list of the cert.

If you wish to use an existing public-signed issuer (such as an ACME provider like Let's Encrypt) then you need to set `signingMethod: public-signed`. This will prevent the creation of certificates that contain host entries that cannot be included when using these issuers.

If your existing issuer is a namespace-local issuer, use `existingIssuer`. If it is a Cluster-wide issuer, use `existingClusterIssuer`. Using the correct type here ensures that certificate requests use the correct one.

When definging certificates to use your existing issuer, they should reference the configuration key under `certificateIssuers` rather than the Issuer resource name. To use the above existing certificate issuer, your certificate definition may look like this:

```
tls:
  certificates:
    certWithExistingIssuer:
      enabled: true
      issuerConfigName: myExistingIssuer
```

### Adding global endpoint module configurations
If you wish to set extra configurations for TLS endpoints, you may do so using the `defaultEndpointConfig` configuration like so:

```
tls:
  defaultEndpointConfig:
    extraCdrConfig:
      tls.protocol.cipher_blacklist: "cipher1,cipher2"
```

In the above example, maybe you wish to set specific TLS cipher restrictions.

By adding the configuration here, you do not need to manually add it to every endpoint module. This allows for simple configuration of TLS endpoints with reduced complexity and scope for errors.
>**Note:** Exercise caution when manipulating the allowed ciphers, as incorrect choices may prevent the readiness probe or ALB health checks from functioning correctly.

More information on available cipher/protocol restriction settings is available [here](https://smilecdr.com/docs/configuration_categories/tls_ssl_encryption.html#property-tls-cipher-blacklist)

### Currently unsupported options
* Use pre-existing cert-manager `Certificate` resources
* Configure `ingress-nginx` to use `Ingress.tls` to configure its TLS termination, instead of the default `self-signed` cert
* Securely import externally provisioned certificate material
* TLS encryption on Azure
