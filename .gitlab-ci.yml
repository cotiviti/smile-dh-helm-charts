# This GitLab CI file will do the following to ensure adherence to the SDLC for Helm Chart development at Smile Digital Health

variables:
  STABLE_BRANCHES_PATTERN: '/^(release-([0-9])+\.)x$|^(main)$/'
  DEVEL_BRANCHES_PATTERN: '/^(pre-release(-([0-9])+\.x)?)$|^(next(-([0-9])+\.x)?)$/'

  TEMPORARY_BRANCHES_PATTERN: '/^(dev|temp|wip)-.*$/i'
  # Used to match against the auto-release commit. Used throughout, but there may be another way.
  SKIP_CI_COMMIT_MESSAGE: '/.*(\[skipci\]|\[skip-ci\]|\[skip_ci\]).*/i'
  SKIP_HELM_CHECK_COMMIT_MESSAGE: '/.*(\[skiphelmcheck\]|\[skip-helmcheck\]|\[skip_helmcheck\]).*/i'
  RELEASE_COMMIT_MESSAGE: '/^chore\(auto-(pre)?release\)/'

workflow:
  rules:

    # Workflow rules to determine when to run pipelines.
    # TODO: Improve this workflow. Study these:
    #  * https://stackoverflow.com/questions/70290807/difference-between-different-gitlab-ci-merge-request-rules
    #  * https://stackoverflow.com/questions/70203979/gitlab-double-pipeline-triggering-issue/70206389#70206389
    # Note: These rules run in order. After the first rule matches, no more rules are processed

    # Do not run if [skip ci] is included in commit message. This applies to all commits,
    # even if used as the source of a Merge Request
    - if: $CI_COMMIT_MESSAGE =~ $SKIP_CI_COMMIT_MESSAGE
      when: never

    # Don't run pipelines for temporary branches
    # - if: $CI_COMMIT_REF_NAME =~ $TEMPORARY_BRANCHES_PATTERN
    #   when: never

    # Run pipeline if this commit is a part of a merge request.
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

    # Prevent duplicate pipelines in the case that this commit is also part of a merge request
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never

    # Prevent pipeline running if there is no commit sha.
    - if: $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      when: never

    # Run release pipelines.
    - if: $CI_COMMIT_REF_NAME =~ $STABLE_BRANCHES_PATTERN

    # Run devel pipeline (Pre-release).
    - if: $CI_COMMIT_REF_NAME =~ $DEVEL_BRANCHES_PATTERN

    # If this were enabled, any commit that is not matched above will run the pipeline. We do not want this.
    # - if: $CI_COMMIT_BRANCH


stages:
- validate        # Run commit message checking, check for default tests
- test            # Run linters, unit tests, outut compare, docs, etc
- release         # Automated release pipeline
- package         # Package the Helm Charts
- publish         # Publish docs, publish Charts to Package Registry

commit-check:
  stage: validate
  tags:
    - helm-ci
  # rules:
  #   - if: $CI_COMMIT_REF_NAME =~ $DEV_BRANCHES_PATTERN
  #     when: never
  image:
    name: commitizen/commitizen:2.37.0
  script:
    - export
    - cz check --rev-range HEAD

helm-lint:
  stage: test
  tags:
    - helm-ci
  image:
    name: alpine/helm:3.10.1
    entrypoint: ["sh", "-c"]
  before_script:
    - apk add bash jq yq
  script:
    - echo "Linting Charts..."
    - ./scripts/lint-charts.sh -s ./src

# Disabling as this does not actually do anything right now
# other than waste GitLab runner resources
# helm-unit-test:
#   stage: test
#   tags:
#     - helm-ci
#   image:
#     name: alpine/helm:3.10.1
#     entrypoint: ["sh", "-c"]
#   script:
#     - echo "Running Helm unit tests..."

helm-output-check:
  stage: test
  tags:
    - helm-ci
  image:
    name: alpine/helm:3.10.1
    entrypoint: ["sh", "-c"]
  before_script:
    - apk add bash jq yq
    - curl --silent --location https://raw.githubusercontent.com/homeport/dyff/main/scripts/download-latest.sh | bash
  script:
    - echo "Checking Helm outputs..."
    - ./scripts/check-outputs.sh -s ${CI_PROJECT_DIR}/src
  rules:
    - if: $CI_COMMIT_MESSAGE =~ $SKIP_HELM_CHECK_COMMIT_MESSAGE
      when: never
    - if: $CI_COMMIT_MESSAGE

helm-docs-check:
  stage: test
  tags:
    - helm-ci
  image:
    name: jnorwood/helm-docs:v1.11.0
    entrypoint: ["sh", "-c"]
  script:
    - helm-docs
      --chart-search-root=${CI_PROJECT_DIR}/src/main/charts
      --template-files=helm-docs/_templates.gotmpl
      --template-files=README.md.gotmpl

helm-package-check:
  stage: test
  tags:
    - helm-ci
  image:
    name: alpine/helm:3.10.1
    entrypoint: ["sh", "-c"]
  script:
    - echo "Testing packaging of Helm Charts..."
    - scripts/prepare-chart-dependencies.sh -s ${CI_PROJECT_DIR}/src
    - helm package src/main/charts/*

# mkdocs-test:
#   stage: test
#   tags:
#     - helm-ci
#   image: python:3.8-buster
#   before_script:
#     - pip install -r requirements.txt
#   script:
#   - mkdocs build --strict --verbose --site-dir mkdocs-test
#   artifacts:
#     paths:
#     - mkdocs-test

pages-test:
  stage: test
  tags:
  - helm-ci
  image: python:3.8-buster
  variables:
    PAGES_BRANCH: gl-pages
  before_script:
  - pip install -r mkdocs-requirements.txt
  - git config user.name smile-docs-bot
  - git config user.email smile-docs-bot@smilecdr.com
  - git fetch origin $PAGES_BRANCH && git checkout -b $PAGES_BRANCH origin/$PAGES_BRANCH || git checkout $PAGES_BRANCH || echo "Pages branch not deployed yet."
  - git checkout $CI_COMMIT_SHA
  script:
  - export CHART_VERSION=$(scripts/get-chart-version.sh)
  - export DOCS_VER=v$(scripts/get-docs-version.sh "${CHART_VERSION}")
  # These do not actually publish the docs. It's just to test that it does not fail,
  # therefore the actual aliases used are unimportant
  - mike deploy --rebase --prefix public -b $PAGES_BRANCH -u v1.0 latest latest-prod latest-pre
  - mike set-default --rebase --prefix public -b $PAGES_BRANCH latest
  - rm -rf public/
  - git checkout $PAGES_BRANCH
  - git status
  - git log -n2

helm-package:
  stage: package
  tags:
    - helm-ci
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
      when: never
    - if: $CI_COMMIT_REF_NAME =~ $STABLE_BRANCHES_PATTERN && $CI_COMMIT_MESSAGE =~ $RELEASE_COMMIT_MESSAGE
    - if: $CI_COMMIT_REF_NAME =~ $DEVEL_BRANCHES_PATTERN && $CI_COMMIT_MESSAGE =~ $RELEASE_COMMIT_MESSAGE
  image:
    name: alpine/helm:3.10.1
    entrypoint: ["sh", "-c"]
  # before_script:
  #   - git config user.name smile-helm-repo-bot
  #   - git config user.email smile-helm-repo-bot@smilecdr.com
  #   - git fetch origin $PAGES_BRANCH && git checkout -b $PAGES_BRANCH origin/$PAGES_BRANCH || git checkout $PAGES_BRANCH || echo "Pages branch not deployed yet."
  #   - git checkout $CI_COMMIT_SHA
  script:
    - echo "Packaging Helm Charts..."
    - scripts/prepare-chart-dependencies.sh -s ${CI_PROJECT_DIR}/src
    - helm package src/main/charts/*
    # - git checkout $PAGES_BRANCH -- public/
    # - echo "Adding charts to GitLab Pages"
    # - mkdir -p public/charts
    # - cp *.tgz public/charts
    # - helm repo index public/charts --url https://smilecdr-public.gitlab.io/smile-dh-helm-charts/charts
    # - git add public/charts
    # - git commit -m "Adding Chart"
    # - git push
  artifacts:
    paths:
      - "*.tgz"
    expire_in: 1 week

helm-publish-devel:
  stage: publish  # It only runs when *both* jobs in the test stage complete successfully.
  tags:
    - helm-ci
  image:
    name: alpine
    # entrypoint: ["sh", "-c"]
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
      when: never
    - if: $CI_COMMIT_REF_NAME =~ $DEVEL_BRANCHES_PATTERN && $CI_COMMIT_MESSAGE =~ $RELEASE_COMMIT_MESSAGE
  before_script:
    - apk add bash curl
    # - 'helm repo add --username gitlab-ci-token --password ${CI_JOB_TOKEN} ${CI_PROJECT_NAME} ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/helm/devel'
    # - 'helm plugin install https://github.com/chartmuseum/helm-push.git'
  script:
    - echo "Publishing Helm Charts to DEVEL channel ..."
    - scripts/publish-charts.sh gitlab-ci-token:$CI_JOB_TOKEN ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/helm/api devel *.tgz
    # - 'curl --request POST --user gitlab-ci-token:$CI_JOB_TOKEN --form "chart=@" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/helm/api/devel/charts"'
    - echo "Helm Charts successfully published to DEVEL channel."

helm-publish-stable:
  stage: publish  # It only runs when *both* jobs in the test stage complete successfully.
  tags:
    - helm-ci
  image:
    name: alpine
    # entrypoint: ["sh", "-c"]
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
      when: never
    - if: $CI_COMMIT_REF_NAME =~ $STABLE_BRANCHES_PATTERN && $CI_COMMIT_MESSAGE =~ $RELEASE_COMMIT_MESSAGE
  before_script:
    - apk add bash curl
  script:
    - echo "Publishing Helm Charts to STABLE channel ..."
    - scripts/publish-charts.sh gitlab-ci-token:$CI_JOB_TOKEN ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/helm/api stable *.tgz
    # - 'curl --request POST --user gitlab-ci-token:$CI_JOB_TOKEN --form "chart=@" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/helm/api/devel/charts"'
    - echo "Helm Charts successfully published to STABLE channel."

pre-release:
  stage: release
  tags:
  - helm-ci
  image:
    name: node:20-alpine
    entrypoint: ["sh", "-c"]
  variables:
    GIT_AUTHOR_NAME: smile-release-bot
    GIT_AUTHOR_EMAIL: smile-release-bot@smilecdr.com
    GIT_COMMITTER_NAME: smile-release-bot
    GIT_COMMITTER_EMAIL: smile-release-bot@smilecdr.com
  before_script:
    - apk add bash curl jq yq git sed
    # Install helm & dyff as they are needed in check outputs script.
    - curl --silent --location https://get.helm.sh/helm-v3.10.1-linux-$(scripts/get-alpine-arch.sh helm).tar.gz | tar -xvzf - -C /usr/local/bin linux-$(scripts/get-alpine-arch.sh helm)/helm --strip-components 1
    - curl --silent --location https://raw.githubusercontent.com/homeport/dyff/main/scripts/download-latest.sh | bash
    # Install helm-docs as we need to update the Helm Chart docs when semantic-release bumps the version
    - curl --silent --location https://github.com/norwoodj/helm-docs/releases/download/v1.11.0/helm-docs_1.11.0_Linux_$(scripts/get-alpine-arch.sh).tar.gz | tar -xzf - -C /usr/local/bin helm-docs
    - npm install @semantic-release/gitlab @semantic-release/changelog @semantic-release/exec @semantic-release/git
    # Use the pre-release configuration for semantic release
    - cp -p .semver-release/.releaserc-devel.yml .releaserc.yml
  rules:
    # Don't run on the auto-release commit. There may be another way...
    - if: $CI_COMMIT_MESSAGE =~ $RELEASE_COMMIT_MESSAGE
      when: never
    # Don't run releases as part of a merge request event.
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
      when: never
    # Run the semver release for pre-release branches
    - if: $CI_COMMIT_REF_NAME =~ $DEVEL_BRANCHES_PATTERN
      when: always
    # This matches pre-releases
    - if: $CI_COMMIT_REF_NAME =~ /^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/
      when: always
  script:
    - npx semantic-release
    # Test to see if semantic-release bumped the version. If not, then get the most recent version tag in this branch and use that.
    # This is passed on to the following docs publish job so that the correct version of the docs is published.
    - test -e .VERSION || (echo $(git describe --abbrev=0 --tags | tr -d v) > .VERSION && touch .NORELEASE)
  artifacts:
    paths:
      - ".VERSION"
      - ".NORELEASE"
    expire_in: 1 week

release:
  stage: release
  tags:
  - helm-ci
  image:
    name: node:20-alpine
    entrypoint: ["sh", "-c"]
  variables:
    GIT_AUTHOR_NAME: smile-release-bot
    GIT_AUTHOR_EMAIL: smile-release-bot@smilecdr.com
    GIT_COMMITTER_NAME: smile-release-bot
    GIT_COMMITTER_EMAIL: smile-release-bot@smilecdr.com
  before_script:
    - apk add bash curl jq yq git sed
    # Install helm & dyff as they are needed in check outputs script.
    - curl --silent --location https://get.helm.sh/helm-v3.10.1-linux-$(scripts/get-alpine-arch.sh helm).tar.gz | tar -xvzf - -C /usr/local/bin linux-$(scripts/get-alpine-arch.sh helm)/helm --strip-components 1
    - curl --silent --location https://raw.githubusercontent.com/homeport/dyff/main/scripts/download-latest.sh | bash
    # Install helm-docs as we need to update the Helm Chart docs when semantic-release bumps the version
    - curl --silent --location https://github.com/norwoodj/helm-docs/releases/download/v1.11.0/helm-docs_1.11.0_Linux_$(scripts/get-alpine-arch.sh).tar.gz | tar -xzf - -C /usr/local/bin helm-docs
    - npm install @semantic-release/gitlab @semantic-release/changelog @semantic-release/exec @semantic-release/git
    # Use the release configuration for semantic release
    - cp -p .semver-release/.releaserc-stable.yml .releaserc.yml
  rules:
    # Don't run on the auto-release commit. There may be another way...
    - if: $CI_COMMIT_MESSAGE =~ $RELEASE_COMMIT_MESSAGE
      when: never
    # Don't run releases as part of a merge request event.
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
      when: never
    # Run the semver release for release branches
    - if: $CI_COMMIT_REF_NAME =~ $STABLE_BRANCHES_PATTERN
      when: always
  script:
    - npx semantic-release
    # Test to see if semantic-release bumped the version. If not, then get the most recent version tag in this branch and use that.
    # This is passed on to the following docs publish job so that the correct version of the docs is published.
    - test -e .VERSION || (echo $(git describe --abbrev=0 --tags | tr -d v) > .VERSION && touch .NORELEASE)
  artifacts:
    paths:
      - ".VERSION"
      - ".NORELEASE"

# Deploy GitLab pages. Job name MUST be `pages`, so do not change it.
# Differing logic for different branches has to be decided within the job as you cannot have multiple `pages` jobs for different branches.
pages:
  stage: publish
  tags:
  - helm-ci
  image: python:3.8-buster
  variables:
    PAGES_BRANCH: gl-pages
    HTTPS_REMOTE: https://gitlab-ci-token:${GITLAB_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git
  before_script:
  - pip install -r mkdocs-requirements.txt
  - git config user.name smile-docs-bot
  - git config user.email smile-docs-bot@smilecdr.com

  script:
  # Ensure that pages branch exists
  - git fetch origin $PAGES_BRANCH && git checkout -b $PAGES_BRANCH origin/$PAGES_BRANCH || git checkout $PAGES_BRANCH || echo "Pages branch not deployed yet."
  - git checkout $CI_COMMIT_SHA
  # ./.VERSION passed as an artifact from release job.
  - VERSION=$(cat  .VERSION)
  - export CHART_VERSION=$(scripts/get-chart-version.sh)
  - export DOCS_VER=v$(scripts/get-docs-version.sh "${VERSION}")
  - export DOCS_ALIASES=$(scripts/get-docs-aliases.sh "${VERSION}")
  - echo "Version ${VERSION}"
  - echo "Docs Version ${DOCS_VER}"
  - echo "Docs Aliases ${DOCS_ALIASES}"
  # Deploy 'release' docs to root path and 'preview' docs to /pre path
  - if [[ "${DOCS_ALIASES}" =~ latest-prod ]] ; then export DOCS_PREFIX=public; else export DOCS_PREFIX=public/pre; fi
  # Mike will build the docs from the current commit and publish them to ${DOCS_VER}.
  - mike deploy --rebase --prefix ${DOCS_PREFIX} -b $PAGES_BRANCH -r ${HTTPS_REMOTE} -p -u ${DOCS_VER} ${DOCS_ALIASES}
  - mike set-default --rebase --prefix ${DOCS_PREFIX} -b $PAGES_BRANCH -r ${HTTPS_REMOTE} -p ${DOCS_VER}
  # This rm step is required as mike populates is as a part of the release process.
  - rm -rf public/
  - git checkout $PAGES_BRANCH
  artifacts:
    paths:
    - public
  rules:
  # Don't run on the auto-release commit. There may be another way...
  - if: $CI_COMMIT_MESSAGE =~ $RELEASE_COMMIT_MESSAGE
    when: never
  # Don't run releases as part of a merge request event.
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    when: never

  # Publish pre-release docs
  - if: $CI_COMMIT_REF_NAME =~ $DEVEL_BRANCHES_PATTERN
    when: always
  # This matches pre-releases
  - if: $CI_COMMIT_REF_NAME =~ /^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/
    when: always

  # Publish release docs
  # This matches releases
  - if: $CI_COMMIT_REF_NAME =~ $STABLE_BRANCHES_PATTERN
    when: always
  # This matches maintenance branches
  - if: $CI_COMMIT_REF_NAME =~ $ALL_MAINTENANCE_BRANCHES_PATTERN
    when: always


include:
  - template: Security/Secret-Detection.gitlab-ci.yml

secret_detection:
  extends: .secret-analyzer
  stage: validate
  tags:
  - helm-ci
  rules:
    - if: $SECRET_DETECTION_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    - /analyzer run
  variables:
    SECRET_DETECTION_HISTORIC_SCAN: "true"
