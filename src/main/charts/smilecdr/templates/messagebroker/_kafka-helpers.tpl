{{- /*
Lightweight template to determine if Kafka is enabled
*/ -}}
{{- define "kafka.enabled" -}}
  {{- $kafkaEnabled := "false" -}}
  {{- /* Determine if this is being called in a 'cdrNode' context or root Helm Values context */ -}}
  {{- $ctx := dict -}}

  {{- if hasKey $.Values "cdrNodeId"  -}}
    {{- /* This is a dynamically generated cdrNode, so we will only return if Kafka is enabled for *this* cdrNode */ -}}

    {{- $strimziEnabled := ternary true false (eq ((include "kafka.strimzi.enabled" . ) | trim ) "true") -}}
    {{- $externalEnabled := ternary true false (eq ((include "kafka.external.enabled" . ) | trim ) "true") -}}
    {{- if and $strimziEnabled $externalEnabled -}}
      {{- fail "You cannot enable strimzi and external Kafka together " -}}
    {{- end -}}
    {{- if or $strimziEnabled $externalEnabled -}}
      {{- $kafkaEnabled = "true" -}}
    {{- end -}}

  {{- else -}}
    {{- /* This is the root context, which means we need to cycle through all nodes to determine if Kafka is enabled in any of them */ -}}
    {{- /* We can simply do this with recursion */ -}}
    {{- range $theCdrNodeName, $theCdrNodeCtx := include "smilecdr.cdrNodes" . | fromYaml -}}
      {{- if eq ((include "kafka.enabled" $theCdrNodeCtx ) | trim ) "true" -}}
        {{- $kafkaEnabled = "true" -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}
  {{- $kafkaEnabled -}}
{{- end -}}

{{- /*
This function builds some commonly used configuration for Kafka settings based
on either external or Strimzi settings.
*/ -}}
{{- define "kafka.config" -}}
  {{- $ctx := get . "Values" -}}

  {{- /* Some configurations only make sense in the context of a cdrNode */ -}}
  {{- /* This flag helps decide whether or not to render them */ -}}
  {{- $contextType := "root" -}}
  {{- if hasKey $ctx "cdrNodeId"  -}}
    {{- $contextType = "cdrNode" -}}
  {{- end -}}
  {{- $secretsList := list -}}
  {{- $strimziSpec := (include "kafka.strimzi.spec" . | fromYaml) -}}
  {{- $externalConfig := (include "kafka.external.config" . | fromYaml) -}}
  {{- $kafkaConfig := dict "externalConfig" $externalConfig "strimziSpec" $strimziSpec -}}
  {{- if and $strimziSpec.enabled $externalConfig.enabled -}}
    {{- fail "You cannot enable strimzi and external Kafka in the same configuration." -}}
  {{- end -}}
  {{- if or $strimziSpec.enabled $externalConfig.enabled -}}
    {{- /* Global Kafka config */ -}}
    {{- $_ := set $kafkaConfig "enabled" "true" -}}

    {{- /* Set default to tls + tls (mTLS) */ -}}
    {{- $kafkaConnectionType := "tls" -}}
    {{- $kafkaAuthentication := dict "type" "tls" -}}
    {{- $kafkaConnectionSecretType := "" -}}
    {{- $kafkaAuthenticationSecretType := "" -}}
    {{- $kafkaBootstrapAddress := "" -}}
    {{- $autoCreateTopics := true -}}

    {{- /* External Kafka Specific config */ -}}
    {{- if $externalConfig.enabled -}}
      {{- $kafkaBootstrapAddress = required "Kafka: You must provide `bootstrapAddress`" $externalConfig.connection.bootstrapAddress -}}
      {{- $kafkaConnectionType = ($externalConfig.connection).type -}}
      {{- $kafkaAuthentication = deepCopy (mergeOverwrite $kafkaAuthentication $externalConfig.authentication) -}}
      {{- $defaultSecretNamePrefix := (printf "%s-kafka" .Release.Name) -}}
      {{- if eq $kafkaConnectionType "tls" -}}
        {{- $caCertType := (default "public" (($externalConfig.connection).caCert).type) -}}
        {{- /* Set the K8s secret name for external Kafka ca cert based on provided `secretName` if any.
             `public`If using this is the only scenario where we enable use of public ca cert for Kafka.
            (i.e. if we are using an external Kafka and do not specify a cert, or explicitly set it to `public`)
            If using `sscsi` and `secretName` is not provided, it uses autogenerated default `<releaseName>-kafka-ca-cert`
            If using `k8sSecret` and `secretName` is not provided, throw an error to the user.
            Default to the `public` behaviour if no caCert is provided */ -}}
        {{- /* Set default value. */ -}}
        {{- $secretName := printf "%s-ca-cert" $defaultSecretNamePrefix -}}

        {{- $privateCa := true -}}
        {{- if eq $caCertType "public" -}}
          {{- $privateCa = false -}}
        {{- else if eq $caCertType "sscsi" -}}
          {{- /* Set based on provided `secretName`. If not provided, leave default value untouched. */ -}}
          {{- if (($externalConfig.connection).caCert).secretName -}}
            {{- $secretName = (($externalConfig.connection).caCert).secretName -}}
          {{- end -}}
        {{- else if eq $caCertType "k8sSecret" -}}
          {{- /* Set based on provided `secretName`. If not provided, throw an error to the user. */ -}}
          {{- $secretName = required "Kafka: You must provide `secretName` for CA cert if using `type: k8sSecret`" (($externalConfig.connection).caCert).secretName -}}
        {{- else -}}
          {{- /* Fail as `caCert.type` is set to an unsupported value */ -}}
          {{- fail (printf "Kafka: CA certificate secret of type `%s` is not currently supported.") -}}
        {{- end -}}

        {{- if $privateCa -}}
          {{- $kafkaConnectionSecretType = $caCertType -}}
          {{- $_ := set $kafkaConfig "caCertSecretName" $secretName -}}

          {{- /* Set up the secret for TLS connection CA Cert... Only if using a private CA */ -}}
          {{- $secretSpec := deepCopy $externalConfig.connection.caCert -}}
          {{- $_ := set $secretSpec "volumeName" "kafka-broker-ca-cert" -}}
          {{- $_ := set $secretSpec "secretName" $secretName -}}
          {{- $_ := set $secretSpec "secretKeyMap" dict -}}
          {{- $_ := set $secretSpec.secretKeyMap "cacert" (dict "secretKeyName" "ca.p12" "k8sSecretKeyName" "ca.p12" "mountSpec" (dict "mountPath" "/home/smile/smilecdr/classes/client_certificates/kafka-ca-cert.p12")) -}}
          {{- $_ := set $secretSpec.secretKeyMap "cacertpassword" (dict "secretKeyName" "ca.password" "k8sSecretKeyName" "ca.password" "envVarName" "KAFKA_BROKER_CA_CERT_PWD") -}}
          {{- $_ := set $secretSpec "useKeyNamesAsAlias" true -}}
          {{- $_ := set $secretSpec "objectAliasDisabled" true -}}
          {{- $secretConfig := include "sdhCommon.secretConfig" (dict "rootCTX" $ "secretSpec" $secretSpec) | fromYaml -}}
          {{- $secretsList = append $secretsList $secretConfig -}}

        {{- end -}}
        {{- $_ := set $kafkaConfig "privateca" $privateCa -}}
      {{- end -}}
      {{- /* if eq $kafkaAuthenticationType "tls" */ -}}
      {{- if contains $kafkaAuthentication.type "mtls tls" -}}
        {{- if or (not (hasKey $externalConfig.authentication "userCert")) (lt (len ($externalConfig.authentication).userCert) 1) -}}
          {{- fail "Kafka: You must configure `userCert` if using TLS authentication." -}}
        {{- end -}}
        {{- $userCert := $externalConfig.authentication.userCert -}}
        {{- $userCertType := (default "k8sSecret" $userCert.type) -}}
        {{- /* Set the K8s secret name for external Kafka user cert based on provided `secretName` if any.
              If using `sscsi` and `secretName` is not provided, it uses autogenerated default `<releaseName>-kafka-user-cert``
              If using `k8sSecret` and `secretName` is not provided, throw an error to the user.
              Default to the `k8sSecret` behaviour if no userCert is provided */ -}}
        {{- /* Set default value. */ -}}
        {{- $secretName := printf "%s-user-cert" $defaultSecretNamePrefix -}}
        {{- if eq $userCertType "sscsi" -}}
          {{- /* Set based on provided `secretName`. If not provided, leave default value untouched. */ -}}
          {{- if $userCert.secretName -}}
            {{- $secretName = $userCert.secretName -}}
          {{- end -}}
        {{- else if eq $userCertType "k8sSecret" -}}
          {{- /* Set based on provided `secretName`. If not provided, throw an error to the user. */ -}}
          {{- $secretName = required "Kafka: You must provide `secretName` for user cert if using `type: k8sSecret`" $userCert.secretName -}}
        {{- else -}}
          {{- /* Fail as `caCert.type` is set to an unsupported value */ -}}
          {{- fail (printf "Kafka: CA certificate secret of type `%s` is not currently supported.") -}}
        {{- end -}}
        {{- $kafkaAuthenticationSecretType = $userCertType -}}
        {{- $_ := set $kafkaConfig "userCertSecretName" $secretName -}}

        {{- /* Set up the secret object */ -}}
        {{- $secretSpec := deepCopy $externalConfig.authentication.userCert -}}
        {{- $_ := set $secretSpec "volumeName" "kafka-client-cert" -}}
        {{- $_ := set $secretSpec "secretName" $secretName -}}
        {{- $_ := set $secretSpec "secretKeyMap" dict -}}
        {{- $_ := set $secretSpec.secretKeyMap "usercert" (dict "secretKeyName" "user.p12" "k8sSecretKeyName" "user.p12" "mountSpec" (dict "mountPath" "/home/smile/smilecdr/classes/client_certificates/kafka-client-cert.p12")) -}}
        {{- $_ := set $secretSpec.secretKeyMap "usercertpassword" (dict "secretKeyName" "user.password" "k8sSecretKeyName" "user.password" "envVarName" "KAFKA_CLIENT_CERT_PWD") -}}
        {{- $_ := set $secretSpec "useKeyNamesAsAlias" true -}}
        {{- $_ := set $secretSpec "objectAliasDisabled" true -}}
        {{- $secretConfig := include "sdhCommon.secretConfig" (dict "rootCTX" $ "secretSpec" $secretSpec) | fromYaml -}}
        {{- $secretsList = append $secretsList $secretConfig -}}

      {{- else if contains $kafkaAuthentication.type "password" -}}
        {{- if or (not (hasKey $externalConfig.authentication "password")) (lt (len ($externalConfig.authentication).password) 1) -}}
          {{- fail "Kafka: You must configure `password` if using password authentication." -}}
        {{- end -}}
        {{- $passwordSpec := $externalConfig.authentication.password -}}
        {{- $passwordSource := (default "k8sSecret" $passwordSpec.type) -}}
        {{- /* Set default value. */ -}}
        {{- $secretName := printf "%s-user-credentials" $defaultSecretNamePrefix -}}
        {{- if eq $passwordSource "sscsi" -}}
          {{- /* Set based on provided `secretName`. If not provided, leave default value untouched. */ -}}
          {{- if $passwordSpec.secretName -}}
            {{- $secretName = $passwordSpec.secretName -}}
          {{- end -}}
        {{- else if eq $passwordSource "k8sSecret" -}}
          {{- /* Set based on provided `secretName`. If not provided, throw an error to the user. */ -}}
          {{- $secretName = required "Kafka: You must provide `secretName` for user credentials if using `type: k8sSecret`" $passwordSpec.secretName -}}
        {{- else -}}
          {{- /* Fail as `caCert.type` is set to an unsupported value */ -}}
          {{- fail (printf "Kafka: Credentials secret of type `%s` is not currently supported.") -}}
        {{- end -}}
        {{- $kafkaAuthenticationSecretType = $passwordSource -}}
        {{- $_ := set $kafkaConfig "passwordSecretName" $secretName -}}

        {{- /* Set up the secret object */ -}}
        {{- $secretSpec := deepCopy $externalConfig.authentication.password -}}
        {{- $_ := set $secretSpec "name" "kafka-authentication-password" -}}
        {{- $_ := set $secretSpec "secretName" $secretName -}}
        {{- $_ := set $secretSpec "secretKeyMap" dict -}}
        {{- $_ := set $secretSpec.secretKeyMap "username" (dict "secretKeyName" "username" "k8sSecretKeyName" "username" "envVarName" "KAFKA_CLIENT_USER") -}}
        {{- $_ := set $secretSpec.secretKeyMap "password" (dict "secretKeyName" "password" "k8sSecretKeyName" "password" "envVarName" "KAFKA_CLIENT_PASS") -}}
        {{- $_ := set $secretSpec "useKeyNamesAsAlias" true -}}
        {{- $_ := set $secretSpec "objectAliasDisabled" true -}}
        {{- $secretConfig := include "sdhCommon.secretConfig" (dict "rootCTX" $ "secretSpec" $secretSpec) | fromYaml -}}
        {{- $secretsList = append $secretsList $secretConfig -}}
      {{- end -}}

    {{- /* Strimzi Specific config */ -}}
    {{- else if $strimziSpec.enabled -}}
      {{- $strimziKafkaSpec := $strimziSpec.kafka -}}
      {{- /* Enable Private CA by default as it's used by Strimzi */ -}}
      {{- $_ := set $kafkaConfig "privateca" true -}}
      {{- $kafkaConnectionType = ($strimziKafkaSpec.connection).type -}}
      {{- $kafkaAuthentication = deepCopy (mergeOverwrite $kafkaAuthentication $strimziKafkaSpec.authentication) -}}
      {{- /* Settings for TLS with Strimzi */ -}}
      {{- if eq $kafkaConnectionType "tls" -}}
        {{- /* K8s secret name for Strimzi ca cert */ -}}
        {{- $secretName := (printf "%s-cluster-ca-cert" .Release.Name) -}}
        {{- $_ := set $kafkaConfig "caCertSecretName" $secretName -}}

        {{- /* Set up the secret for TLS connection CA Cert... Only if using a private CA */ -}}
        {{- $secretSpec := dict "secretName" $secretName -}}
        {{- $_ := set $secretSpec "volumeName" "kafka-broker-ca-cert" -}}
        {{- $_ := set $secretSpec "secretKeyMap" dict -}}
        {{- $_ := set $secretSpec.secretKeyMap "cacert" (dict "secretKeyName" "ca.p12" "k8sSecretKeyName" "ca.p12" "mountSpec" (dict "mountPath" "/home/smile/smilecdr/classes/client_certificates/kafka-ca-cert.p12")) -}}
        {{- $_ := set $secretSpec.secretKeyMap "cacertpassword" (dict "secretKeyName" "ca.password" "k8sSecretKeyName" "ca.password" "envVarName" "KAFKA_BROKER_CA_CERT_PWD") -}}
        {{- $_ := set $secretSpec "useKeyNamesAsAlias" true -}}
        {{- $_ := set $secretSpec "objectAliasDisabled" true -}}
        {{- $secretConfig := include "sdhCommon.secretConfig" (dict "rootCTX" $ "secretSpec" $secretSpec) | fromYaml -}}
        {{- $secretsList = append $secretsList $secretConfig -}}

        {{- /* Kafka bootstrap servers for Strimzi tls listener */ -}}
        {{- /*TODO: Make the bootstrap address autoconfigure from the Strimzi configuration */ -}}
        {{- $kafkaBootstrapAddress = printf "%s-kafka-bootstrap:9093" .Release.Name -}}
      {{- else -}}
        {{- $kafkaBootstrapAddress = printf "%s-kafka-bootstrap:9093" .Release.Name -}}
      {{- end -}}

      {{- if contains $kafkaAuthentication.type "mtls tls" -}}
        {{- /* Set the K8s secret name for Strimzi user cert */ -}}
        {{- $secretName := (printf "%s-kafka-user" .Release.Name) -}}
        {{- $_ := set $kafkaConfig "userCertSecretName" $secretName -}}

        {{- /* Set up the secret for TLS connection CA Cert... Only if using a private CA */ -}}
        {{- $secretSpec := dict "secretName" $secretName -}}
        {{- $_ := set $secretSpec "volumeName" "kafka-client-cert" -}}
        {{- $_ := set $secretSpec "secretKeyMap" dict -}}
        {{- $_ := set $secretSpec.secretKeyMap "cacert" (dict "secretKeyName" "user.p12" "k8sSecretKeyName" "user.p12" "mountSpec" (dict "mountPath" "/home/smile/smilecdr/classes/client_certificates/kafka-client-cert.p12")) -}}
        {{- $_ := set $secretSpec.secretKeyMap "cacertpassword" (dict "secretKeyName" "user.password" "k8sSecretKeyName" "user.password" "envVarName" "KAFKA_CLIENT_CERT_PWD") -}}
        {{- $_ := set $secretSpec "useKeyNamesAsAlias" true -}}
        {{- $_ := set $secretSpec "objectAliasDisabled" true -}}
        {{- $secretConfig := include "sdhCommon.secretConfig" (dict "rootCTX" $ "secretSpec" $secretSpec) | fromYaml -}}
        {{- $secretsList = append $secretsList $secretConfig -}}

      {{- end -}}
    {{- end -}}

    {{- /* Topic management */ -}}
    {{- /* Only supported in Strimzi right now */ -}}
    {{- if and .Values.messageBroker.manageTopics $strimziSpec.enabled -}}
      {{- $strimziKafkaSpec := $strimziSpec.kafka -}}
      {{- /* Update the topics to be suitable for the existing Strimzi configuration */ -}}
      {{- range $k, $v := .Values.messageBroker.topics -}}
        {{- $_ := set (get $.Values.messageBroker.topics $k) "replicas" $strimziKafkaSpec.replicas -}}
      {{- end -}}
      {{- $_ := set $kafkaConfig "topics" .Values.messageBroker.topics -}}
      {{- $autoCreateTopics = false -}}
    {{- else -}}
      {{- $_ := set $kafkaConfig "topics" dict -}}
    {{- end -}}

    {{- $_ := set $kafkaConfig "connection" (dict "type" $kafkaConnectionType "secretType" $kafkaConnectionSecretType) -}}
    {{- $_ := set $kafkaConfig "authentication" $kafkaAuthentication -}}
    {{- $_ := set $kafkaConfig.authentication "secretType" $kafkaAuthenticationSecretType -}}
    {{- $_ := set $kafkaConfig "bootstrapAddress" $kafkaBootstrapAddress -}}
    {{- $_ := set $kafkaConfig "autoCreateTopics" $autoCreateTopics -}}

    {{- /* If auto create topics is enabled, then validate topics should be false */ -}}
    {{- /* If auto create topics is disabled (i.e. if Strimzi or anothet process is creating topics), then validate topics should be true */ -}}
    {{- $validateTopics := "" -}}
    {{- if not $autoCreateTopics -}}
      {{- $_ := set $kafkaConfig "validateTopics" true -}}
    {{- end -}}

    {{- /* If using IAM auth (i.e. using Amazon MSK) topics should not be auto created, `validate_topics_before_use` should be enabled */ -}}
    {{- if eq $kafkaConfig.authentication.type "iam" -}}
      {{- $_ := set $kafkaConfig "validateTopics" true -}}
    {{- end -}}

    {{- /* Allow overriding */ -}}
    {{- if hasKey .Values.messageBroker "validateTopics" -}}
      {{- $_ := set $kafkaConfig "validateTopics" .Values.messageBroker.validateTopics -}}
    {{- end -}}

    {{- $_ := set $kafkaConfig "propertiesResourceName" $autoCreateTopics -}}

    {{- if hasKey $ctx.messageBroker "clientConfiguration" -}}
      {{- $_ := set $kafkaConfig "consumerProperties" (default (dict) (deepCopy $ctx.messageBroker.clientConfiguration.consumerProperties)) -}}
      {{- $_ := set $kafkaConfig "producerProperties" (get $ctx.messageBroker.clientConfiguration "producerProperties" ) -}}

    {{- end -}}

    {{- $consumerPropertiesData := include "kafka.consumer.properties.text" $kafkaConfig -}}
    {{- $producerPropertiesData := include "kafka.producer.properties.text" $kafkaConfig -}}

    {{- $_ := set $kafkaConfig "consumerPropertiesData" $consumerPropertiesData -}}
    {{- $_ := set $kafkaConfig "producerPropertiesData" $producerPropertiesData -}}
    {{- $propsHashSuffix := ternary (printf "-%s" (include "smilecdr.getHashSuffix" (printf "%s/n%s" $consumerPropertiesData $producerPropertiesData))) "" $ctx.autoDeploy -}}

    {{- /* Set name for Kafka client properties ConfigMap */ -}}
    {{- /* Only include cdrNode name in client properties if in 'cdrNode' context */ -}}
    {{- if eq $contextType "cdrNode" -}}
      {{- $_ := set $kafkaConfig "propertiesResourceName" (printf "%s-kafka-client-properties-%s-node%s" $.Release.Name ($ctx.cdrNodeName | lower) $propsHashSuffix) -}}
      {{- /* TODO: Remove when `oldResourceNaming` is removed */ -}}
      {{- if $ctx.oldResourceNaming -}}
        {{- $_ := set $kafkaConfig "propertiesResourceName" (printf "%s-kafka-client-properties-%s-node%s" $.Release.Name ($ctx.cdrNodeName | lower) $propsHashSuffix) -}}
      {{- end -}}
    {{- else -}}
      {{- $_ := set $kafkaConfig "propertiesResourceName" (printf "%s-kafka-client-properties-%s" $.Release.Name $propsHashSuffix) -}}
    {{- end -}}

    {{- if gt (len $secretsList) 0 -}}
      {{- $_ := set $kafkaConfig "secrets" $secretsList -}}
    {{- end -}}

  {{- end -}}
  {{- $kafkaConfig | toYaml -}}
{{- end -}}

{{- /*
Define Kafka related volumes requird by Smile CDR pod
Currently only supports mounting of the properties files
*/ -}}
{{- define "kafka.volumes" -}}
  {{- $volumes := list -}}

  {{- $kafkaConfig := include "kafka.config" . | fromYaml -}}
  {{- if $kafkaConfig.enabled -}}
  {{- /* if eq ((include "kafka.enabled" . ) | trim ) "true" */ -}}
    {{- /* $kafkaConfig := (include "kafka.config" . | fromYaml) */ -}}
    {{- /* if $kafkaConfig.enabled */ -}}

    {{- /* Mount client properties files */ -}}
    {{- $configMap := (dict "name" $kafkaConfig.propertiesResourceName) -}}
    {{- $propsVolume := dict "name" "kafka-client-config" "configMap" $configMap -}}
    {{- $volumes = append $volumes $propsVolume -}}

    {{- /* Mount any certs defined in secrets */ -}}
    {{- range $secret := $kafkaConfig.secrets -}}
      {{- range $volume := $secret.volumeMap -}}
        {{- $volumes = append $volumes $volume -}}
      {{- end -}}
    {{- end -}}

  {{- end -}}
  {{- $volumes | toYaml -}}
{{- end -}}

{{- /*
Define Kafka related volume mounts requird by Smile CDR container
*/ -}}
{{- define "kafka.volumeMounts" -}}
  {{- $volumeMounts := list -}}
  {{- $kafkaConfig := include "kafka.config" . | fromYaml -}}
  {{- if $kafkaConfig.enabled -}}
    {{- /* Mount consumer properties file */ -}}
    {{- $volumeMount := dict "name" "kafka-client-config" -}}
    {{- $_ := set $volumeMount "mountPath" "/home/smile/smilecdr/classes/cdr_kafka_config/cdr-kafka-consumer-config.properties" -}}
    {{- $_ := set $volumeMount "subPath" "consumer.properties" -}}
    {{- $_ := set $volumeMount "readOnly" true -}}
    {{- $volumeMounts = append $volumeMounts $volumeMount -}}
    {{- /* Mount producer properties file */ -}}
    {{- $volumeMount = dict "name" "kafka-client-config" -}}
    {{- $_ := set $volumeMount "mountPath" "/home/smile/smilecdr/classes/cdr_kafka_config/cdr-kafka-producer-config.properties" -}}
    {{- $_ := set $volumeMount "subPath" "producer.properties" -}}
    {{- $_ := set $volumeMount "readOnly" true -}}
    {{- $volumeMounts = append $volumeMounts $volumeMount -}}
    {{- /* Mount any certs defined in secrets */ -}}
    {{- range $secret := $kafkaConfig.secrets -}}
      {{- range $volumeMount := $secret.volumeMountMap -}}
        {{- $volumeMounts = append $volumeMounts $volumeMount -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}
  {{- $volumeMounts | toYaml -}}
{{- end -}}

{{- /*
Define env vars that will be used for Kafka certificate
passwords
*/ -}}
{{- define "kafka.envVars" -}}
  {{- $envVars := list -}}
  {{- $kafkaConfig := (include "kafka.config" . | fromYaml) -}}
  {{- if $kafkaConfig.enabled -}}

    {{- /* Global Env vars */ -}}
    {{- $envVars = append $envVars (dict "name" "KAFKA_BOOTSTRAP_ADDRESS" "value" $kafkaConfig.bootstrapAddress) -}}

    {{- /* Env vars if using TLS and private cert */ -}}
    {{- if eq $kafkaConfig.connection.type "tls" -}}
      {{- $envVars = append $envVars (dict "name" "KAFKA_SSL_ENABLED" "value" "true") -}}
    {{- else -}}
      {{- $envVars = append $envVars (dict "name" "KAFKA_SSL_ENABLED" "value" "false") -}}
    {{- end -}}

    {{- /* Env Vars mapped to secrets */ -}}
    {{- range $theKafkaSecretSpec := $kafkaConfig.secrets -}}
      {{- range $env := $theKafkaSecretSpec.envMap -}}
        {{- $envVars = append $envVars $env -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}
  {{- $envVars | toYaml -}}
{{- end -}}

{{/*
Define any file copies required by Amazon MSK IAM auth
*/}}
{{- define "kafka.iamJarConfig" -}}
    {{- $kafkaConfig := . -}}
    {{- $iamConfig := dict -}}
    {{- /* Autojar copy enabled by default */ -}}
    {{- $_ := set $iamConfig "autoJarCopy" true -}}
    {{- $_ := set $iamConfig "adminAutoJarCopy" true -}}
    {{- $_ := set $iamConfig "copyType" "curl" -}}
    {{- $_ := set $iamConfig "fileName" "aws-msk-iam-auth-1.1.9-all.jar" -}}
    {{- $_ := set $iamConfig "url" "https://github.com/aws/aws-msk-iam-auth/releases/download/v1.1.9/aws-msk-iam-auth-1.1.9-all.jar" -}}
    {{- if hasKey $kafkaConfig.authentication "iamConfig" -}}
      {{- $iamConfig = deepCopy (mergeOverwrite $iamConfig $kafkaConfig.authentication.iamConfig ) -}}
    {{- end -}}
    {{- $iamConfig | toYaml -}}
{{- end -}}


{{/*
Define any file copies required by Amazon MSK IAM auth
*/}}
{{ define "kafka.iamJar.sources" }}
  {{- $iamConfig := . -}}
  {{- $iamJarSource := dict -}}
  {{- if eq $iamConfig.copyType "curl" -}}
    {{- $url := required "You must specify a URL to copy classes files from." $iamConfig.url -}}
    {{- $fileName := required "You must specify a destination `fileName` for classes files." $iamConfig.fileName -}}
    {{- $iamJarSource = (dict "type" "curl" "url" $url "fileName" $fileName) -}}
  {{- else if eq $iamConfig.copyType "s3" -}}
    {{- $bucket := required "You must specify an S3 bucket to copy IAM auth Jar file from." $iamConfig.bucket -}}
    {{- $bucketPath := required "You must specify the full S3 bucket path for the IAM auth Jar file." $iamConfig.path -}}
    {{- $iamJarSource = (dict "type" "s3" "bucket" $bucket "path" $bucketPath) -}}
  {{- end -}}
  {{- $iamJarSource | toYaml -}}
{{- end -}}

{{/*
Define any file copies required by Kafka for Smile CDR
*/}}
{{- define "kafka.customerlib.sources" -}}
  {{- $customerlibFileSources := list -}}
  {{- /* Add Kafka MSK IAM Jar, only if auth type is set to `iam` */ -}}
  {{- $kafkaConfig := (include "kafka.config" . | fromYaml) -}}
  {{- if and $kafkaConfig.enabled (eq $kafkaConfig.authentication.type "iam") -}}
    {{- $kafkaIamConfig := (include "kafka.iamJarConfig" $kafkaConfig | fromYaml) -}}
    {{- if $kafkaIamConfig.autoJarCopy -}}
      {{- $customerlibFileSources = append $customerlibFileSources (include "kafka.iamJar.sources" $kafkaIamConfig | fromYaml) -}}
    {{- end -}}
  {{- end -}}
  {{- $customerlibFileSources | toYaml  -}}
{{- end -}}

{{/*
Define any file copies required by Kafka for Admin Pod
*/}}
{{- define "kafka.admin.classpath.sources" -}}
  {{- $customerlibFileSources := list -}}
  {{- /* Add Kafka MSK IAM Jar, only if auth type is set to `iam` */ -}}
  {{- $kafkaConfig := (include "kafka.config" . | fromYaml) -}}
  {{- if and $kafkaConfig.enabled (eq $kafkaConfig.authentication.type "iam") -}}
    {{- $kafkaIamConfig := (include "kafka.iamJarConfig" $kafkaConfig | fromYaml) -}}
    {{- if $kafkaIamConfig.adminAutoJarCopy -}}
      {{- $customerlibFileSources = append $customerlibFileSources (include "kafka.iamJar.sources" $kafkaIamConfig | fromYaml) -}}
    {{- end -}}
  {{- end -}}
  {{- $customerlibFileSources | toYaml  -}}
{{- end -}}

{{- /*
Define Kafka consumer properties file
*/ -}}
{{- define "kafka.consumer.properties.text" -}}
  {{- $props := "# Kafka consumer properties auto generated from Helm Chart. Do not edit manually!\n" -}}
  {{- $kafkaConfig := . -}}
  {{- range $k, $v := $kafkaConfig.consumerProperties -}}
    {{- $props = printf "%s\n%s=%d" $props $k (int $v) -}}
  {{- end -}}
  {{- if eq $kafkaConfig.authentication.type "iam" -}}
    {{- $props = printf "%s\n%s=%s" $props "sasl.mechanism" "AWS_MSK_IAM" -}}
    {{- $props = printf "%s\n%s=%s" $props "sasl.jaas.config" "software.amazon.msk.auth.iam.IAMLoginModule required;" -}}
    {{- $props = printf "%s\n%s=%s" $props "sasl.client.callback.handler.class" "software.amazon.msk.auth.iam.IAMClientCallbackHandler" -}}
  {{- end -}}
  {{- $props -}}
{{- end -}}

{{- /*
Define Kafka producer properties file
*/ -}}
{{- define "kafka.producer.properties.text" -}}
  {{- $props := "# Kafka producer properties auto generated from Helm Chart. Do not edit manually!\n" -}}
  {{- $kafkaConfig := . -}}
  {{- range $k, $v := $kafkaConfig.producerProperties -}}
    {{- $props = printf "%s\n%s=%d" $props $k (int $v) -}}
  {{- end -}}
  {{- if eq $kafkaConfig.authentication.type "iam" -}}
      {{- $props = printf "%s\n%s=%s" $props "sasl.mechanism" "AWS_MSK_IAM" -}}
      {{- $props = printf "%s\n%s=%s" $props "sasl.jaas.config" "software.amazon.msk.auth.iam.IAMLoginModule required;" -}}
      {{- $props = printf "%s\n%s=%s" $props "sasl.client.callback.handler.class" "software.amazon.msk.auth.iam.IAMClientCallbackHandler" -}}
  {{- end -}}
  {{- $props -}}
{{- end -}}
