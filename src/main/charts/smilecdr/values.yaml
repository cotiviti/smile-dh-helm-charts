
database:
  # Either crunchypgo or external should be set to true. Not both.
  # If using external DB, then Kubernetes secret needs to be set up with
  # the correct credentials. See docs.
  crunchypgo:
    enabled: true
    internal: false
    config:
      postgresVersion: 14
      instanceReplicas: 1
      instanceSize: 10Gi
      backupsSize: 10Gi
      users:
        # Defining users here will cause the username and the database to be
        # created using the Crunchy PGO.
        - name: "smilecdr"
          databases:
            - smilecdr

    # Only change this if you change the SmileCDR username in postgresscluster.users
    # userName: smilecdr
  external:
    enabled: false
    # credentialsSource can be k8s or AWS Secrets Manager. Others to be implemented later.
    credentialsSource: k8s
    # TODO: Explain how to configure secret.
    secretName: changeme
    dbType: postgres
    port: 5432

kafka:
  enabled: false
  bootstrapAddress: kafka-example.local
  channelPrefix: SCDR-ENV-
  #TODO: More Kafka properties

specs:
  hostname: smilecdr-example.local
  # Define a common root context path, if required.
  #rootPath: /

# Extra labels
labels: {}

# Define modules to be used. Some of these will contain service definitions.
# A service and an ingress rule will be created for modules that use services.
# Canonical endpoint URLs will be generated by _smile-module-helpers.tpl and
# populated in the smilecdr.services variable. These can be consumed by other
# modules that reference them.
modules:
  usedefaultmodules: true

# Define modules in extra values files. This increases readability of the main
# values file, as well as enabling more modular and automated addition of modules
# without having to touch this file
externalModuleDefinitions:
  default: default-modules.yaml

mappedFiles: {}
#   testfile.txt:
#     type: configMap
#     configMapBaseName: smilecdr
#     path: /home/smile/smilecdr/classes

# This is where we define multiple node configurations for SmileCDR
# This is a developing feature and there may be breaking changes later on
# For now, it only defines the name, which is used in the properties ConfigMap
# It may later be used to define deployment-specific attributes.
# @ignored
cdrNodes:
  Masterdev:
    enabled: true # Not used yet.

# Number of replicas to deploy. Note that this setting is ignored if autoscaling
# is enabled.
replicaCount: 1

# Automatically do rolling deployment when configmaps or files are changed
autoDeploy: true

image:
  repository: docker.smilecdr.com/smilecdr
  # Override only if you have created a K8s docker config secret externally to this Helm Chart
  # If you specify credentials here, a K8s docker config secret will be auto generated.
  # Do not use in production environments.
  credentials:
    # Choose one of sscsi, extsecret, values
    # type: sscsi
    # provider: aws
    # secretarn: "arn:aws:secretsmanager:us-east-1:1234567890:secret:secretname"
    #
    # type: extsecret
    # pullSecrets:
    #   - name: scdr-docker-secrets
    type: values
    values:
      - registry: docker.com
        username: user
        password: pass
  pullPolicy: IfNotPresent
  # Override the image tag. Default is the chart appVersion.
  tag: '2022.08.R03'

jvm:
  memoryFactor: 1
  xms: true
  args:
    - "-Dsun.net.inetaddr.ttl=60"
    - "-Djava.security.egd=file:/dev/./urandom"

serviceAccount:
  # Specifies whether a service account should be created
  create: false
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  # We won't define annotations here as they are defined in the helper template
  # annotations: {}
  # Define any extra annotations. Please keep cloud vendor specific annotations in the
  # helper template
  extraAnnotations: {}

ingress:
  enabled: true
  # Select the cloud vendor and GW/NLB controller being used.
  # Currently supported values are:
  # nginx-ingress - Nginx Ingress Controller (Network Load Balancer when using AWS Load Balancer Controller)
  # aws-lbc-alb - AWS Load Balancer Controller (Application Load Balancer)
  # azure-appgw - Azure Application Gateway
  # other - If it is none of the above, or unset, no default Ingress annotations will be created. It is up to
  #         you to provide appropriate `extraAnnotations` below
  type: nginx-ingress

  # This chart assumes certain default Ingress Class names. If your environment has defined a different class
  # name then override it here
  #ingressClassNameOverride:

  # We won't define annotations here as they are defined in the helper template
  # annotations: {}
  # Define any extra annotations. Please keep cloud vendor specific annotations in the
  # helper template
  extraAnnotations: {}

resources:
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  requests:
    cpu: "1"
    memory: 2Gi
  limits:
    cpu: "2"
    memory: 4Gi

autoscaling:
  enabled: false
  # minReplicas: Recommend 1 for dev environments, 2 for prod or 3 for HA prod
  # Should always start a new installation with 1, so it's the default
  minReplicas: 1
  # Depends on peak workload requirements and available licensing
  maxReplicas: 4
  targetCPUUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}
